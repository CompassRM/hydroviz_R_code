code)
data_to_insert <- filter(L_data_bridge_NOid, is.na(db_matches))
DATA_BRIDGE_inserted <- data_to_insert
num_insert <- length(data_to_insert[[1]])
num_dups <- num_df - num_insert
# 3 - dbWriteTable to append the new values
if (num_insert > 0) {
RPostgreSQL::dbWriteTable(
connection,
"data_bridge",
data_to_insert,
row.names = FALSE,
append = TRUE,
overwrite = FALSE
)
message(
c(
num_df,
" DATA_BRIDGEs in df, ",
num_dups,
" duplicates, ",
num_insert,
" inserted in DB"
)
)
} else {
message(
c(
num_df,
" DATA_BRIDGEs in df, ",
num_dups,
" duplicates, ",
num_insert,
" inserted in DB"
)
)
}
length(data_to_insert[[1]])
# Nothing to insert!
message(c(
num_df,
" DATA in df, ",
num_dups,
" duplicates, ",
num_insert,
" inserted in DB"
))
source('~/Box/P722 - MRRIC AM Support/Working Docs/P722 - HydroViz/hydroviz_R_code/Hydroviz_PushToPSQL.R')
message("Processing DATA_TABLE")
data_processing_start <- Sys.time()
# Make a LOCAL version of the data with a 'code' field
bridge_table_temp$code <-
paste(
bridge_table_temp$alternative_id,
bridge_table_temp$type_id,
bridge_table_temp$source_id,
bridge_table_temp$river_id,
bridge_table_temp$location_id
)
LOCAL_data <-
dplyr::select(bridge_table_temp, id, date, value, code)
# Count how many rows in the local dataset BEFORE removing rows that exist in the DB
num_df <- length(LOCAL_data$id)
codes_to_insert <- data_to_insert$code
num_to_insert <- length(codes_to_insert)
num_dups <- num_df - num_to_insert
(length(num_to_insert) == 0)
length(num_to_insert)
num_to_insert
codes_to_insert
data_to_insert
(num_to_insert == 0)
(num_to_insert > 0)
source('~/Box/P722 - MRRIC AM Support/Working Docs/P722 - HydroViz/hydroviz_R_code/Hydroviz_PushToPSQL.R')
message("Processing DATA_TABLE")
data_processing_start <- Sys.time()
# Make a LOCAL version of the data with a 'code' field
bridge_table_temp$code <-
paste(
bridge_table_temp$alternative_id,
bridge_table_temp$type_id,
bridge_table_temp$source_id,
bridge_table_temp$river_id,
bridge_table_temp$location_id
)
LOCAL_data <-
dplyr::select(bridge_table_temp, id, date, value, code)
# Count how many rows in the local dataset BEFORE removing rows that exist in the DB
num_df <- length(LOCAL_data$id)
codes_to_insert <- data_to_insert$code
num_to_insert <- length(codes_to_insert)
num_dups <- num_df - num_to_insert
if (num_to_insert > 0) {
# query the table to see which values exist in the DB compared to my dataframe
# This gives us the 'data_bridge_ids' that correspond to the 'codes'
DB_data_bridge <- dbReadTable(connection, "data_bridge")
# MUST do the step below to get the row index for matches, THEN get the corresponding ID for those rows
data_bridge_index <-
match(
LOCAL_data$code,
DB_data_bridge$code,
nomatch = NA_integer_,
incomparables = NULL
)
# Find the data_bridge_id where LOCAL_data already exists in the DB
LOCAL_data$data_bridge_id <- DB_data_bridge$id[data_bridge_index]
LOCAL_data_to_insert <-
dplyr::filter(LOCAL_data, LOCAL_data$code %in% codes_to_insert)
DATA_inserted <- LOCAL_data_to_insert
# Process data to add missing columns before inserting into DB
# Add year, month, day to data table
LOCAL_data_to_insert$year <-
lubridate::year(LOCAL_data_to_insert$date)
LOCAL_data_to_insert$month_num <-
lubridate::month(LOCAL_data_to_insert$date)
LOCAL_data_to_insert$day_num <-
lubridate::day(LOCAL_data_to_insert$date)
# ****CHECK THIS - LOOKS LIKE IT RETURNS 365 VALUES?!
LOCAL_data_to_insert$year_dates_id <-
DB_year_dates[DB_year_dates$month == LOCAL_data_to_insert$month &&
DB_year_dates$day == LOCAL_data_to_insert$day, "id"]
modeled_dates_index <-
match(
as.character(LOCAL_data_to_insert$date),
DB_modeled_dates$date,
nomatch = NA_integer_,
incomparables = NULL
)
LOCAL_data_to_insert$date <-
DB_modeled_dates$id[modeled_dates_index]
LOCAL_data_to_insert <-
dplyr::rename(LOCAL_data_to_insert, modeled_dates_id = date)
# Reorder columns
LOCAL_data_to_insert <-
LOCAL_data_to_insert[c(
"id",
"data_bridge_id",
"modeled_dates_id",
"value",
"year_dates_id",
"year",
"month_num",
"day_num"
)]
# Convert values to numeric
options(digits = 9)
LOCAL_data_to_insert$value <-
as.numeric(LOCAL_data_to_insert$value)
end_time <- Sys.time()
elapsed_time <-
difftime(end_time, data_processing_start, units = "secs")
message(c(
"It took ",
round(elapsed_time[[1]], 2),
" seconds to process the data table for ",
length(LOCAL_data_to_insert),
"rows of data."
))
# Drop the ID column
LOCAL_data_to_insert_NO_ID <-
dplyr::select(
LOCAL_data_to_insert,
data_bridge_id,
modeled_dates_id,
value,
year_dates_id,
year,
month_num,
day_num
)
# INSERT into data table
message(c("Inserting into 'DATA' table..."))
SQL_start <- Sys.time()
# Write to DB
RPostgreSQL::dbWriteTable(
connection,
"data",
LOCAL_data_to_insert_NO_ID,
row.names = FALSE,
append = TRUE,
overwrite = FALSE
)
message(c(
num_df,
" DATA in df, ",
num_dups,
" duplicates, ",
num_insert,
" inserted in DB"
))
end_time <- Sys.time()
elapsed_time <- difftime(end_time, SQL_start, units = "secs")
message(c(
"SQL insert into 'DATA' complete. Elapsed time: ",
round(elapsed_time[[1]], 2),
" seconds. "
))
} else {
# Nothing to insert!
message(c(
num_df,
" DATA in df, ",
num_dups,
" duplicates, ",
num_insert,
" inserted in DB"
))
}
-------------
message("Processing Stats for STATS_TABLE: ")
start_time <- Sys.time()
stats_data_temp <-
tidyr::spread(LOCAL_data_to_insert_NO_ID[, c("data_bridge_id", "year_dates_id", "year", "value")], year, value)
stats_data_temp <-
cbind(id = 1:nrow(stats_data_temp), stats_data_temp)
stats <- data.frame(
minimum = numeric(),
tenth = numeric(),
fiftieth = numeric(),
average = numeric(),
ninetieth = numeric(),
maximum = numeric()
)
pb <-
txtProgressBar(
min = 1,
max = nrow(stats_data_temp),
initial = 1,
char = "=",
width = NA,
"title",
"label",
style = 3,
file = ""
)
for (i in 1:nrow(stats_data_temp)) {
setTxtProgressBar(pb, i)
stats[i, c("tenth", "fiftieth", "ninetieth")] <-
quantile(stats_data_temp[i, 4:ncol(stats_data_temp)], probs = c(0.1, 0.5, 0.9))
stats[i, "minimum"] <-
min(stats_data_temp[i, 4:ncol(stats_data_temp)])
stats[i, "average"] <-
mean(unlist(stats_data_temp[i, 4:ncol(stats_data_temp)]))
stats[i, "maximum"] <-
max(stats_data_temp[i, 4:ncol(stats_data_temp)])
}
close(pb)
stats_data_temp <-
tidyr::spread(LOCAL_data_to_insert_NO_ID[, c("data_bridge_id", "year_dates_id", "year", "value")], year, value)
source('~/Box/P722 - MRRIC AM Support/Working Docs/P722 - HydroViz/hydroviz_R_code/Hydroviz_PushToPSQL.R')
source('~/Box/P722 - MRRIC AM Support/Working Docs/P722 - HydroViz/hydroviz_R_code/Hydroviz_PushToPSQL.R')
if (num_to_insert > 0) {
message("**No stats to process**")
} else {
message("Processing Stats for STATS_TABLE: ")
start_time <- Sys.time()
stats_data_temp <-
tidyr::spread(LOCAL_data_to_insert_NO_ID[, c("data_bridge_id", "year_dates_id", "year", "value")], year, value)
stats_data_temp <-
cbind(id = 1:nrow(stats_data_temp), stats_data_temp)
stats <- data.frame(
minimum = numeric(),
tenth = numeric(),
fiftieth = numeric(),
average = numeric(),
ninetieth = numeric(),
maximum = numeric()
)
pb <-
txtProgressBar(
min = 1,
max = nrow(stats_data_temp),
initial = 1,
char = "=",
width = NA,
"title",
"label",
style = 3,
file = ""
)
for (i in 1:nrow(stats_data_temp)) {
setTxtProgressBar(pb, i)
stats[i, c("tenth", "fiftieth", "ninetieth")] <-
quantile(stats_data_temp[i, 4:ncol(stats_data_temp)], probs = c(0.1, 0.5, 0.9))
stats[i, "minimum"] <-
min(stats_data_temp[i, 4:ncol(stats_data_temp)])
stats[i, "average"] <-
mean(unlist(stats_data_temp[i, 4:ncol(stats_data_temp)]))
stats[i, "maximum"] <-
max(stats_data_temp[i, 4:ncol(stats_data_temp)])
}
close(pb)
end_time <- Sys.time()
elapsed_time <- difftime(end_time, start_time, units = "secs")
message(c(
"It took ",
round(elapsed_time[[1]], 2),
" seconds to calculate stats for  ",
nrow(stats_data_temp),
" rows of data"
))
LOCAL_model_stats <- stats_data_temp[, 1:3]
LOCAL_model_stats <- cbind(LOCAL_model_stats, stats)
LOCAL_model_stats_all <- cbind(stats_data_temp, stats)
num_df <- length(LOCAL_model_stats$id)
# MUST remove the ID column before pushing to the DB
LOCAL_model_stats_NO_ID <-
dplyr::select(
LOCAL_model_stats,
data_bridge_id,
year_dates_id,
minimum,
tenth,
fiftieth,
average,
ninetieth,
maximum
)
# STATS_inserted <- to_insert
STATS_inserted <- LOCAL_model_stats_NO_ID
num_insert <- length(LOCAL_model_stats_NO_ID[[1]])
num_dups <- num_df - num_insert
# 3 - dbWriteTable to append the new values
message(c("Inserting into 'STATS' table..."))
SQL_start <- Sys.time()
RPostgreSQL::dbWriteTable(
connection,
"stats",
LOCAL_model_stats_NO_ID,
row.names = FALSE,
append = TRUE,
overwrite = FALSE
)
message(c(
num_df,
" STATS in df, ",
num_dups,
" duplicates, ",
num_insert,
" inserted in DB"
))
end_time <- Sys.time()
elapsed_time <- difftime(end_time, SQL_start, units = "secs")
message(c(
"SQL insert into 'STATS' complete. Elapsed time: ",
round(elapsed_time[[1]], 2),
" seconds. "
))
}
num_to_insert
source('~/Box/P722 - MRRIC AM Support/Working Docs/P722 - HydroViz/hydroviz_R_code/Hydroviz_PushToPSQL.R')
(num_to_insert == 0)
if (num_to_insert == 0) {
message("**No stats to process**")
} else {
message("Processing Stats for STATS_TABLE: ")
start_time <- Sys.time()
stats_data_temp <-
tidyr::spread(LOCAL_data_to_insert_NO_ID[, c("data_bridge_id", "year_dates_id", "year", "value")], year, value)
stats_data_temp <-
cbind(id = 1:nrow(stats_data_temp), stats_data_temp)
stats <- data.frame(
minimum = numeric(),
tenth = numeric(),
fiftieth = numeric(),
average = numeric(),
ninetieth = numeric(),
maximum = numeric()
)
pb <-
txtProgressBar(
min = 1,
max = nrow(stats_data_temp),
initial = 1,
char = "=",
width = NA,
"title",
"label",
style = 3,
file = ""
)
for (i in 1:nrow(stats_data_temp)) {
setTxtProgressBar(pb, i)
stats[i, c("tenth", "fiftieth", "ninetieth")] <-
quantile(stats_data_temp[i, 4:ncol(stats_data_temp)], probs = c(0.1, 0.5, 0.9))
stats[i, "minimum"] <-
min(stats_data_temp[i, 4:ncol(stats_data_temp)])
stats[i, "average"] <-
mean(unlist(stats_data_temp[i, 4:ncol(stats_data_temp)]))
stats[i, "maximum"] <-
max(stats_data_temp[i, 4:ncol(stats_data_temp)])
}
close(pb)
end_time <- Sys.time()
elapsed_time <- difftime(end_time, start_time, units = "secs")
message(c(
"It took ",
round(elapsed_time[[1]], 2),
" seconds to calculate stats for  ",
nrow(stats_data_temp),
" rows of data"
))
LOCAL_model_stats <- stats_data_temp[, 1:3]
LOCAL_model_stats <- cbind(LOCAL_model_stats, stats)
LOCAL_model_stats_all <- cbind(stats_data_temp, stats)
num_df <- length(LOCAL_model_stats$id)
# MUST remove the ID column before pushing to the DB
LOCAL_model_stats_NO_ID <-
dplyr::select(
LOCAL_model_stats,
data_bridge_id,
year_dates_id,
minimum,
tenth,
fiftieth,
average,
ninetieth,
maximum
)
# STATS_inserted <- to_insert
STATS_inserted <- LOCAL_model_stats_NO_ID
num_insert <- length(LOCAL_model_stats_NO_ID[[1]])
num_dups <- num_df - num_insert
# 3 - dbWriteTable to append the new values
message(c("Inserting into 'STATS' table..."))
SQL_start <- Sys.time()
RPostgreSQL::dbWriteTable(
connection,
"stats",
LOCAL_model_stats_NO_ID,
row.names = FALSE,
append = TRUE,
overwrite = FALSE
)
message(c(
num_df,
" STATS in df, ",
num_dups,
" duplicates, ",
num_insert,
" inserted in DB"
))
end_time <- Sys.time()
elapsed_time <- difftime(end_time, SQL_start, units = "secs")
message(c(
"SQL insert into 'STATS' complete. Elapsed time: ",
round(elapsed_time[[1]], 2),
" seconds. "
))
}
source('~/Box/P722 - MRRIC AM Support/Working Docs/P722 - HydroViz/hydroviz_R_code/Hydroviz_PushToPSQL.R')
PushToPSQL(df)
save_tables_flag
(!exists("save_tables_flag"))
(!exists("save_tables_flag"))
((!exists("save_tables_flag")) | TRUE)
source('~/Box/P722 - MRRIC AM Support/Working Docs/P722 - HydroViz/hydroviz_R_code/Hydroviz_PushToPSQL.R')
save_tables_flag != "yes"
exists("save_tables_flag")
source('~/Box/P722 - MRRIC AM Support/Working Docs/P722 - HydroViz/hydroviz_R_code/Hydroviz_PushToPSQL.R')
source('~/Box/P722 - MRRIC AM Support/Working Docs/P722 - HydroViz/hydroviz_R_code/Hydroviz_PushToPSQL.R')
source('~/Box/P722 - MRRIC AM Support/Working Docs/P722 - HydroViz/hydroviz_R_code/Hydroviz_PushToPSQL.R')
source('~/Box/P722 - MRRIC AM Support/Working Docs/P722 - HydroViz/hydroviz_R_code/Hydroviz_PushToPSQL.R')
PushToPSQL(df)
source('~/Box/P722 - MRRIC AM Support/Working Docs/P722 - HydroViz/hydroviz_R_code/Hydroviz_PushToPSQL.R')
PushToPSQL(df)
source('~/Box/P722 - MRRIC AM Support/Working Docs/P722 - HydroViz/hydroviz_R_code/Hydroviz_PushToPSQL.R')
source('~/Box/P722 - MRRIC AM Support/Working Docs/P722 - HydroViz/hydroviz_R_code/Hydroviz_DataProcessing.R')
# CLEAR EVERYTHING AT THE START
rm(list = ls())
cat("\014")
while (dev.cur() > 1)
dev.off()
# NOTE - must set the working directory to the directory where this R file is run from! E.g.:
setwd("~/Box/P722 - MRRIC AM Support/Working Docs/P722 - HydroViz/hydroviz_R_code")
source("Hydroviz_DataProcessing.R")
source("Hydroviz_PushToPSQL.R")
source('~/Box/P722 - MRRIC AM Support/Working Docs/P722 - HydroViz/hydroviz_R_code/Hydroviz_DataProcessing.R')
ProcessHydrovizData()
save_tables <- "no"
save_tables
source('~/Box/P722 - MRRIC AM Support/Working Docs/P722 - HydroViz/hydroviz_R_code/Hydroviz_DataProcessing.R')
source('~/Box/P722 - MRRIC AM Support/Working Docs/P722 - HydroViz/hydroviz_R_code/Hydroviz_PushToPSQL.R')
source('~/Box/P722 - MRRIC AM Support/Working Docs/P722 - HydroViz/hydroviz_R_code/Hydroviz_PushToPSQL.R')
ProcessHydrovizData()
source('~/Box/P722 - MRRIC AM Support/Working Docs/P722 - HydroViz/hydroviz_R_code/Hydroviz_PushToPSQL.R')
source('~/Box/P722 - MRRIC AM Support/Working Docs/P722 - HydroViz/hydroviz_R_code/Hydroviz_PushToPSQL.R')
ProcessHydrovizData()
source('~/Box/P722 - MRRIC AM Support/Working Docs/P722 - HydroViz/hydroviz_R_code/Hydroviz_DataProcessing.R')
source('~/Box/P722 - MRRIC AM Support/Working Docs/P722 - HydroViz/hydroviz_R_code/Hydroviz_PushToPSQL.R')
source('~/Box/P722 - MRRIC AM Support/Working Docs/P722 - HydroViz/hydroviz_R_code/Hydroviz_PushToPSQL.R')
source('~/Box/P722 - MRRIC AM Support/Working Docs/P722 - HydroViz/hydroviz_R_code/Hydroviz_PushToPSQL.R')
source('~/Box/P722 - MRRIC AM Support/Working Docs/P722 - HydroViz/hydroviz_R_code/Hydroviz_PushToPSQL.R')
source('~/Box/P722 - MRRIC AM Support/Working Docs/P722 - HydroViz/hydroviz_R_code/Hydroviz_PushToPSQL.R')
source('~/Box/P722 - MRRIC AM Support/Working Docs/P722 - HydroViz/hydroviz_R_code/Hydroviz_PushToPSQL.R')
source('~/Box/P722 - MRRIC AM Support/Working Docs/P722 - HydroViz/hydroviz_R_code/Hydroviz_PushToPSQL.R')
ProcessHydrovizData()
source('~/Box/P722 - MRRIC AM Support/Working Docs/P722 - HydroViz/hydroviz_R_code/Hydroviz_PushToPSQL.R')
ProcessHydrovizData()
source('~/Box/P722 - MRRIC AM Support/Working Docs/P722 - HydroViz/hydroviz_R_code/Hydroviz_PushToPSQL.R')
source('~/Box/P722 - MRRIC AM Support/Working Docs/P722 - HydroViz/hydroviz_R_code/Hydroviz_PushToPSQL.R')
source('~/Box/P722 - MRRIC AM Support/Working Docs/P722 - HydroViz/hydroviz_R_code/Hydroviz_PushToPSQL.R')
ProcessHydrovizData()
source('~/Box/P722 - MRRIC AM Support/Working Docs/P722 - HydroViz/hydroviz_R_code/Hydroviz_DataProcessing.R')
source('~/Box/P722 - MRRIC AM Support/Working Docs/P722 - HydroViz/hydroviz_R_code/Hydroviz_DataProcessing.R')
ProcessHydrovizData()
source('~/Box/P722 - MRRIC AM Support/Working Docs/P722 - HydroViz/hydroviz_R_code/Hydroviz_PushToPSQL.R')
ProcessHydrovizData()
source('~/Box/P722 - MRRIC AM Support/Working Docs/P722 - HydroViz/hydroviz_R_code/Hydroviz_PushToPSQL.R')
dbDisconnect(connection)
source('~/Box/P722 - MRRIC AM Support/Working Docs/P722 - HydroViz/hydroviz_R_code/Hydroviz_PushToPSQL.R')
source('~/Box/P722 - MRRIC AM Support/Working Docs/P722 - HydroViz/hydroviz_R_code/Hydroviz_PushToPSQL.R')
